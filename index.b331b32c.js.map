{"mappings":"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","sources":["<anon>","src/scripts/main.js","src/modules/Game.class.js"],"sourcesContent":["\"use strict\";\nvar $a5fd07fa01589658$exports = {};\n\"use strict\";\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */ class $a5fd07fa01589658$var$Game {\n    /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */ constructor(initialState){\n        // eslint-disable-next-line no-console\n        if (initialState) {\n            this.initialState = initialState;\n            this.board = JSON.parse(JSON.stringify(initialState));\n        } else this.board = [\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ]\n        ];\n        this.gameIsStarted = false;\n        this.mergedTiles = [];\n        this.mergedTilesValues = [];\n        this.cellState = this.createCellState(initialState);\n        this.highScore = localStorage.getItem(\"highScore\") || 0;\n    }\n    updateHighScore() {\n        const score = this.getScore();\n        if (score > this.highScore) {\n            this.highScore = score;\n            localStorage.setItem(\"highScore\", this.highScore);\n        }\n    }\n    moveLeft() {\n        if (!this.gameIsStarted || !this.canMoveLeft()) return;\n        this.moveCells(this.board);\n        const { cell: cell, randomValue: randomValue } = this.newTile();\n        return this.slideTiles(this.cellState).finally(()=>{\n            if (cell) cell.tile = new $a5fd07fa01589658$var$Tile(cell, randomValue);\n        });\n    }\n    moveRight() {\n        if (!this.gameIsStarted || !this.canMoveRight()) return;\n        const reversedState = this.getReversed(this.board);\n        const board = this.moveCells(reversedState);\n        this.board = this.getReversed(board);\n        const { cell: cell, randomValue: randomValue } = this.newTile();\n        return this.slideTiles(this.cellState.map((row)=>[\n                ...row\n            ].reverse())).finally(()=>{\n            if (cell) cell.tile = new $a5fd07fa01589658$var$Tile(cell, randomValue);\n        });\n    }\n    moveUp() {\n        if (!this.gameIsStarted || !this.canMoveUp()) return;\n        const stateByColumn = this.getElementsByColumn(this.board);\n        const board = this.moveCells(stateByColumn);\n        this.board = this.getElementsByColumn(board);\n        const { cell: cell, randomValue: randomValue } = this.newTile();\n        return this.slideTiles(this.cellsByColumn).finally(()=>{\n            if (cell) cell.tile = new $a5fd07fa01589658$var$Tile(cell, randomValue);\n        });\n    }\n    moveDown() {\n        if (!this.gameIsStarted || !this.canMoveDown()) return;\n        const stateByColumn = this.getElementsByColumn(this.board);\n        const reversedState = this.getReversed(stateByColumn);\n        const board = this.moveCells(reversedState);\n        const revertReverseState = this.getReversed(board);\n        this.board = this.getElementsByColumn(revertReverseState);\n        const { cell: cell, randomValue: randomValue } = this.newTile();\n        return this.slideTiles(this.cellsByColumn.map((column)=>[\n                ...column\n            ].reverse())).finally(()=>{\n            if (cell) cell.tile = new $a5fd07fa01589658$var$Tile(cell, randomValue);\n        });\n    }\n    /**\n   * @returns {number}\n   */ getScore() {\n        const score = this.mergedTilesValues.reduce((sum, cell)=>{\n            return sum + cell;\n        }, 0);\n        return score;\n    }\n    /**\n   * @returns {number[][]}\n   */ getState() {\n        return this.board;\n    }\n    /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */ getStatus() {\n        if (this.isWinner()) {\n            this.updateHighScore();\n            return \"win\";\n        }\n        if (this.gameIsStarted && this.noMovesPossible) {\n            this.updateHighScore();\n            return \"lose\";\n        }\n        if (this.gameIsStarted) return \"playing\";\n        return \"idle\";\n    }\n    /**\n   * Starts the game.\n   */ start() {\n        const { cell: cell, randomValue: randomValue } = this.newTile();\n        if (cell) cell.tile = new $a5fd07fa01589658$var$Tile(cell, randomValue);\n        const { cell: cell2, randomValue: randomValue2 } = this.newTile();\n        if (cell2) cell2.tile = new $a5fd07fa01589658$var$Tile(cell2, randomValue2);\n        this.gameIsStarted = true;\n    }\n    /**\n   * Resets the game.\n   */ restart() {\n        if (this.initialState) this.board = JSON.parse(JSON.stringify(this.initialState));\n        else this.board.forEach((row)=>{\n            for(let i = 0; i < row.length; i++){\n                const cell = row[i];\n                if (cell) row[i] = 0;\n            }\n        });\n        this.mergedTiles = [];\n        this.mergedTilesValues = [];\n        this.gameIsStarted = false;\n        if (this.cellState) this.cellState.forEach((row)=>{\n            for(let i = 0; i < row.length; i++){\n                const cell = row[i];\n                if (cell.tile) {\n                    cell.tile.remove();\n                    cell.tile = null;\n                }\n                if (cell.mergeTile) {\n                    cell.mergeTile.remove();\n                    cell.tile = null;\n                }\n            }\n        });\n        this.cellState = this.createCellState(this.initialState);\n    }\n    createCellState(initialState = []) {\n        const cellState = document.querySelectorAll(\".field-row\");\n        return [\n            ...cellState\n        ].map((row, y)=>{\n            const cells = [\n                ...row.children\n            ];\n            const updatedRow = [];\n            for(let x = 0; x < cells.length; x++){\n                const cell = cells[x];\n                const newCell = new $a5fd07fa01589658$var$Cell(cell, x, y);\n                if (initialState.length > 0) {\n                    const initialRow = initialState[y];\n                    const initialValue = initialRow[x];\n                    if (initialValue !== 0) {\n                        const tile = new $a5fd07fa01589658$var$Tile(newCell, initialValue);\n                        newCell.tile = tile;\n                    }\n                }\n                updatedRow.push(newCell);\n            }\n            return updatedRow;\n        });\n    }\n    get randomCell() {\n        const randomCells = [];\n        this.board.forEach((row, y)=>{\n            for(let x = 0; x < row.length; x++)if (!row[x] || row[x] === 0) randomCells.push([\n                x,\n                y\n            ]);\n        });\n        if (randomCells.length === 0) return;\n        const index = Math.floor(Math.random() * randomCells.length);\n        return randomCells[index];\n    }\n    newTile() {\n        const randomCell = this.randomCell;\n        if (!randomCell) return;\n        const [x, y] = randomCell;\n        const randomValue = Math.random() <= 0.1 ? 4 : 2;\n        this.board[y][x] = randomValue;\n        let cell;\n        if (this.cellState[y]) cell = this.cellState[y][x];\n        return {\n            cell: cell,\n            randomValue: randomValue\n        };\n    }\n    getCoords(cell) {\n        const x = +cell.dataset.x;\n        const y = +cell.dataset.y;\n        return {\n            x: x,\n            y: y\n        };\n    }\n    moveCells(board) {\n        this.mergedTiles = [];\n        for(let y = 0; y < board.length; y++){\n            const boardRow = board[y];\n            for(let x = 1; x < boardRow.length; x++){\n                const cell = boardRow[x];\n                if (cell === 0) continue;\n                let lastValidIndex;\n                for(let i = x - 1; i >= 0; i--){\n                    const moveToCell = boardRow[i];\n                    const isCellMerged = this.mergedTiles.length > 0 ? this.mergedTiles.find(([x1, y1])=>i === x1 && y === y1) : false;\n                    if (!this.canCellAcceptTile(moveToCell, cell, isCellMerged)) break;\n                    lastValidIndex = i;\n                }\n                if (lastValidIndex || lastValidIndex === 0) {\n                    if (boardRow[lastValidIndex] === boardRow[x]) {\n                        this.mergedTiles.push([\n                            lastValidIndex,\n                            y\n                        ]);\n                        boardRow[lastValidIndex] = boardRow[x] * 2;\n                        this.mergedTilesValues.push(boardRow[x] * 2);\n                    }\n                    if (boardRow[lastValidIndex] === 0) boardRow[lastValidIndex] = boardRow[x];\n                    boardRow[x] = 0;\n                }\n            }\n        }\n        return board;\n    }\n    canCellAcceptTile(targetCell, tile, isCellMerged) {\n        return !targetCell || targetCell === tile && !isCellMerged;\n    }\n    get cellsByColumn() {\n        const board = this.cellState;\n        const newBoard = [];\n        for(let y = 0; y < board.length; y++){\n            const column = board.map((row)=>row[y]);\n            newBoard.push(column);\n        }\n        return newBoard;\n    }\n    get tableByColumn() {\n        const board = this.cellState;\n        const newBoard = [];\n        for(let y = 0; y < board.length; y++){\n            const column = board.map((row)=>row[y]);\n            newBoard.push(column);\n        }\n        return newBoard;\n    }\n    slideTiles(group) {\n        return Promise.all(group.flatMap((cells)=>{\n            const promises = [];\n            for(let x = 1; x < cells.length; x++){\n                const cellTile = cells[x].tile;\n                const currentCell = cells[x];\n                if (!cellTile) continue;\n                let lastValidCell;\n                for(let i = x - 1; i >= 0; i--){\n                    const moveToCell = cells[i];\n                    if (!moveToCell.canAcceptTile(cellTile)) break;\n                    lastValidCell = moveToCell;\n                }\n                if (lastValidCell) {\n                    if (lastValidCell.tile) {\n                        promises.push(cellTile.waitForTransition());\n                        if (!lastValidCell.mergeTile) lastValidCell.mergeTile = cellTile;\n                    } else {\n                        lastValidCell.tile = cellTile;\n                        promises.push(cellTile.waitForTransition());\n                    }\n                    currentCell.tile = null;\n                }\n            }\n            return promises;\n        }));\n    }\n    canMove(group) {\n        return group.some((row, y)=>{\n            return row.some((cell, index)=>{\n                if (index === 0) return false;\n                if (cell === 0) return false;\n                return this.canCellAcceptTile(row[index - 1], cell, false);\n            });\n        });\n    }\n    getElementsByColumn(group) {\n        const newBoard = [];\n        for(let y = 0; y < group.length; y++){\n            const column = group.map((row)=>row[y]);\n            newBoard.push(column);\n        }\n        return newBoard;\n    }\n    getReversed(group) {\n        return group.map((column)=>[\n                ...column\n            ].reverse());\n    }\n    canMoveLeft() {\n        return this.canMove(this.board);\n    }\n    canMoveRight() {\n        const reversed = this.getReversed(this.board);\n        return this.canMove(reversed);\n    }\n    canMoveUp() {\n        const stateByColumn = this.getElementsByColumn(this.board);\n        return this.canMove(stateByColumn);\n    }\n    canMoveDown() {\n        const stateByColumn = this.getElementsByColumn(this.board);\n        const reversed = this.getReversed(stateByColumn);\n        return this.canMove(reversed);\n    }\n    get noMovesPossible() {\n        return !this.canMoveDown() && !this.canMoveUp() && !this.canMoveLeft() && !this.canMoveRight();\n    }\n    isWinner() {\n        return this.mergedTilesValues.some((cell)=>cell === 2048);\n    }\n}\nclass $a5fd07fa01589658$var$Cell {\n    #tile;\n    #mergeTile;\n    constructor(cellElement, x, y){\n        this.cellElement = cellElement;\n        this.x = x;\n        this.y = y;\n    }\n    set tile(value) {\n        this.#tile = value;\n        if (!value) return;\n        this.tile.x = +this.x;\n        this.tile.y = +this.y;\n    }\n    get tile() {\n        return this.#tile;\n    }\n    get mergeTile() {\n        return this.#mergeTile;\n    }\n    set mergeTile(value) {\n        this.#mergeTile = value;\n        if (!value) return;\n        this.#mergeTile.x = this.x;\n        this.#mergeTile.y = this.y;\n    }\n    canAcceptTile(tile) {\n        return !this.tile || this.tile.value === tile.value && !this.mergeTile;\n    }\n    mergeTiles() {\n        if (!this.tile || !this.#mergeTile) return;\n        this.tile.value = +this.tile.value + +this.#mergeTile.value;\n        this.#mergeTile.remove();\n        this.#mergeTile = null;\n    }\n}\nclass $a5fd07fa01589658$var$Tile {\n    #x;\n    #y;\n    #value;\n    constructor(parentElement, initValue){\n        const newTile = document.createElement(\"div\");\n        const { cellElement: cellElement, x: x, y: y } = parentElement;\n        newTile.style.setProperty(\"--coord-y\", y);\n        newTile.style.setProperty(\"--coord-x\", x);\n        newTile.textContent = initValue;\n        newTile.className = `field-cell game-cell field-cell--${initValue}`;\n        this.tileElement = newTile;\n        this.#x = x;\n        this.#y = y;\n        this.#value = +initValue;\n        cellElement.append(newTile);\n    }\n    set x(coordX) {\n        this.#x = +coordX;\n        this.tileElement.style.setProperty(\"--coord-x\", +coordX);\n    }\n    get x() {\n        return this.#x;\n    }\n    set y(coordY) {\n        this.#y = +coordY;\n        this.tileElement.style.setProperty(\"--coord-y\", +coordY);\n    }\n    get y() {\n        return this.#y;\n    }\n    set value(value1) {\n        if (value1) {\n            this.#value = +value1;\n            this.tileElement.textContent = value1.toString();\n            this.tileElement.className = `field-cell game-cell field-cell--${value1}`;\n        }\n    }\n    get value() {\n        return this.#value;\n    }\n    remove() {\n        this.tileElement.remove();\n    }\n    waitForTransition() {\n        return new Promise((resolve)=>{\n            this.tileElement.addEventListener(\"transitionend\", resolve, {\n                once: true\n            });\n        });\n    }\n}\n$a5fd07fa01589658$exports = $a5fd07fa01589658$var$Game;\n\n\nconst $09e991522ca7e64e$var$game = new $a5fd07fa01589658$exports();\nconst $09e991522ca7e64e$var$button = document.querySelector(\"button\");\nconst $09e991522ca7e64e$var$messages = document.querySelectorAll(\".message\");\nconst $09e991522ca7e64e$var$startMessage = document.querySelector(\".message-start\");\nconst $09e991522ca7e64e$var$gameScore = document.querySelector(\".game-score\");\nconst $09e991522ca7e64e$var$bestScore = document.querySelector(\".best .game-score\");\nconst $09e991522ca7e64e$var$highScore = parseInt(localStorage.getItem(\"highScore\")) || 0;\n$09e991522ca7e64e$var$bestScore.textContent = $09e991522ca7e64e$var$highScore;\n$09e991522ca7e64e$var$button.addEventListener(\"click\", ()=>{\n    const isStartButton = $09e991522ca7e64e$var$button.classList.contains(\"start\");\n    $09e991522ca7e64e$var$button.textContent = isStartButton ? \"Restart\" : \"Start\";\n    if (isStartButton) {\n        $09e991522ca7e64e$var$game.start();\n        $09e991522ca7e64e$var$button.classList.replace(\"start\", \"restart\");\n    } else {\n        $09e991522ca7e64e$var$game.restart();\n        $09e991522ca7e64e$var$handleScoreChange(0);\n        $09e991522ca7e64e$var$button.classList.replace(\"restart\", \"start\");\n        $09e991522ca7e64e$var$messages.forEach((message)=>{\n            if (!message.classList.contains(\"hiiden\")) message.classList.add(\"hidden\");\n        });\n    }\n    $09e991522ca7e64e$var$startMessage.classList.toggle(\"hidden\");\n});\nfunction $09e991522ca7e64e$var$setupInput() {\n    document.addEventListener(\"keydown\", $09e991522ca7e64e$var$handleInput, {\n        once: true\n    });\n}\nasync function $09e991522ca7e64e$var$handleInput(e) {\n    switch(e.key){\n        case \"ArrowLeft\":\n            await $09e991522ca7e64e$var$game.moveLeft();\n            break;\n        case \"ArrowRight\":\n            await $09e991522ca7e64e$var$game.moveRight();\n            break;\n        case \"ArrowUp\":\n            await $09e991522ca7e64e$var$game.moveUp();\n            break;\n        case \"ArrowDown\":\n            await $09e991522ca7e64e$var$game.moveDown();\n            break;\n        default:\n            $09e991522ca7e64e$var$setupInput();\n            return;\n    }\n    $09e991522ca7e64e$var$game.cellState.flat().forEach((cell)=>{\n        cell.mergeTiles();\n    });\n    $09e991522ca7e64e$var$handleStatusChange($09e991522ca7e64e$var$game.getStatus());\n    $09e991522ca7e64e$var$handleScoreChange($09e991522ca7e64e$var$game.getScore());\n    if (!$09e991522ca7e64e$var$game.isWinner() || !$09e991522ca7e64e$var$game.noMovesPossible()) $09e991522ca7e64e$var$setupInput();\n}\n$09e991522ca7e64e$var$setupInput();\nfunction $09e991522ca7e64e$var$handleStatusChange(gameStatus) {\n    $09e991522ca7e64e$var$messages.forEach((message)=>{\n        if (message.classList.contains(`message-${gameStatus}`)) message.classList.remove(\"hidden\");\n    });\n}\nfunction $09e991522ca7e64e$var$handleScoreChange(currentScore) {\n    $09e991522ca7e64e$var$gameScore.textContent = currentScore;\n    if (currentScore > $09e991522ca7e64e$var$highScore) {\n        // eslint-disable-next-line no-shadow\n        const highScore = currentScore;\n        $09e991522ca7e64e$var$bestScore.textContent = highScore;\n        localStorage.setItem(\"highScore\", highScore);\n    }\n}\n\n\n//# sourceMappingURL=index.b331b32c.js.map\n","'use strict';\n\nconst Game = require('../modules/Game.class');\n\nconst game = new Game();\n\nconst button = document.querySelector('button');\nconst messages = document.querySelectorAll('.message');\nconst startMessage = document.querySelector('.message-start');\n\nconst gameScore = document.querySelector('.game-score');\nconst bestScore = document.querySelector('.best .game-score');\n\nconst highScore = parseInt(localStorage.getItem('highScore')) || 0;\n\nbestScore.textContent = highScore;\n\nbutton.addEventListener('click', () => {\n  const isStartButton = button.classList.contains('start');\n\n  button.textContent = isStartButton ? 'Restart' : 'Start';\n\n  if (isStartButton) {\n    game.start();\n    button.classList.replace('start', 'restart');\n  } else {\n    game.restart();\n    handleScoreChange(0);\n    button.classList.replace('restart', 'start');\n\n    messages.forEach((message) => {\n      if (!message.classList.contains('hiiden')) {\n        message.classList.add('hidden');\n      }\n    });\n  }\n\n  startMessage.classList.toggle('hidden');\n});\n\nfunction setupInput() {\n  document.addEventListener('keydown', handleInput, { once: true });\n}\n\nasync function handleInput(e) {\n  switch (e.key) {\n    case 'ArrowLeft':\n      await game.moveLeft();\n      break;\n    case 'ArrowRight':\n      await game.moveRight();\n      break;\n    case 'ArrowUp':\n      await game.moveUp();\n      break;\n    case 'ArrowDown':\n      await game.moveDown();\n      break;\n    default:\n      setupInput();\n\n      return;\n  }\n\n  game.cellState.flat().forEach((cell) => {\n    cell.mergeTiles();\n  });\n\n  handleStatusChange(game.getStatus());\n  handleScoreChange(game.getScore());\n\n  if (!game.isWinner() || !game.noMovesPossible()) {\n    setupInput();\n  }\n}\n\nsetupInput();\n\nfunction handleStatusChange(gameStatus) {\n  messages.forEach((message) => {\n    if (message.classList.contains(`message-${gameStatus}`)) {\n      message.classList.remove('hidden');\n    }\n  });\n}\n\nfunction handleScoreChange(currentScore) {\n  gameScore.textContent = currentScore;\n\n  if (currentScore > highScore) {\n    // eslint-disable-next-line no-shadow\n    const highScore = currentScore;\n\n    bestScore.textContent = highScore;\n    localStorage.setItem('highScore', highScore);\n  }\n}\n","'use strict';\n\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n  constructor(initialState) {\n    // eslint-disable-next-line no-console\n    if (initialState) {\n      this.initialState = initialState;\n      this.board = JSON.parse(JSON.stringify(initialState));\n    } else {\n      this.board = [\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n      ];\n    }\n    this.gameIsStarted = false;\n    this.mergedTiles = [];\n    this.mergedTilesValues = [];\n\n    this.cellState = this.createCellState(initialState);\n    this.highScore = localStorage.getItem('highScore') || 0;\n  }\n\n  updateHighScore() {\n    const score = this.getScore();\n\n    if (score > this.highScore) {\n      this.highScore = score;\n      localStorage.setItem('highScore', this.highScore);\n    }\n  }\n\n  moveLeft() {\n    if (!this.gameIsStarted || !this.canMoveLeft()) {\n      return;\n    }\n\n    this.moveCells(this.board);\n\n    const { cell, randomValue } = this.newTile();\n\n    return this.slideTiles(this.cellState).finally(() => {\n      if (cell) {\n        cell.tile = new Tile(cell, randomValue);\n      }\n    });\n  }\n\n  moveRight() {\n    if (!this.gameIsStarted || !this.canMoveRight()) {\n      return;\n    }\n\n    const reversedState = this.getReversed(this.board);\n\n    const board = this.moveCells(reversedState);\n\n    this.board = this.getReversed(board);\n\n    const { cell, randomValue } = this.newTile();\n\n    return this.slideTiles(\n      this.cellState.map((row) => [...row].reverse()),\n    ).finally(() => {\n      if (cell) {\n        cell.tile = new Tile(cell, randomValue);\n      }\n    });\n  }\n\n  moveUp() {\n    if (!this.gameIsStarted || !this.canMoveUp()) {\n      return;\n    }\n\n    const stateByColumn = this.getElementsByColumn(this.board);\n\n    const board = this.moveCells(stateByColumn);\n\n    this.board = this.getElementsByColumn(board);\n\n    const { cell, randomValue } = this.newTile();\n\n    return this.slideTiles(this.cellsByColumn).finally(() => {\n      if (cell) {\n        cell.tile = new Tile(cell, randomValue);\n      }\n    });\n  }\n\n  moveDown() {\n    if (!this.gameIsStarted || !this.canMoveDown()) {\n      return;\n    }\n\n    const stateByColumn = this.getElementsByColumn(this.board);\n    const reversedState = this.getReversed(stateByColumn);\n\n    const board = this.moveCells(reversedState);\n\n    const revertReverseState = this.getReversed(board);\n\n    this.board = this.getElementsByColumn(revertReverseState);\n\n    const { cell, randomValue } = this.newTile();\n\n    return this.slideTiles(\n      this.cellsByColumn.map((column) => [...column].reverse()),\n    ).finally(() => {\n      if (cell) {\n        cell.tile = new Tile(cell, randomValue);\n      }\n    });\n  }\n\n  /**\n   * @returns {number}\n   */\n  getScore() {\n    const score = this.mergedTilesValues.reduce((sum, cell) => {\n      return sum + cell;\n    }, 0);\n\n    return score;\n  }\n\n  /**\n   * @returns {number[][]}\n   */\n  getState() {\n    return this.board;\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    if (this.isWinner()) {\n      this.updateHighScore();\n\n      return 'win';\n    }\n\n    if (this.gameIsStarted && this.noMovesPossible) {\n      this.updateHighScore();\n\n      return 'lose';\n    }\n\n    if (this.gameIsStarted) {\n      return 'playing';\n    }\n\n    return 'idle';\n  }\n\n  /**\n   * Starts the game.\n   */\n  start() {\n    const { cell, randomValue } = this.newTile();\n\n    if (cell) {\n      cell.tile = new Tile(cell, randomValue);\n    }\n\n    const { cell: cell2, randomValue: randomValue2 } = this.newTile();\n\n    if (cell2) {\n      cell2.tile = new Tile(cell2, randomValue2);\n    }\n\n    this.gameIsStarted = true;\n  }\n\n  /**\n   * Resets the game.\n   */\n  restart() {\n    if (this.initialState) {\n      this.board = JSON.parse(JSON.stringify(this.initialState));\n    } else {\n      this.board.forEach((row) => {\n        for (let i = 0; i < row.length; i++) {\n          const cell = row[i];\n\n          if (cell) {\n            row[i] = 0;\n          }\n        }\n      });\n    }\n\n    this.mergedTiles = [];\n    this.mergedTilesValues = [];\n    this.gameIsStarted = false;\n\n    if (this.cellState) {\n      this.cellState.forEach((row) => {\n        for (let i = 0; i < row.length; i++) {\n          const cell = row[i];\n\n          if (cell.tile) {\n            cell.tile.remove();\n            cell.tile = null;\n          }\n\n          if (cell.mergeTile) {\n            cell.mergeTile.remove();\n            cell.tile = null;\n          }\n        }\n      });\n    }\n\n    this.cellState = this.createCellState(this.initialState);\n  }\n\n  createCellState(initialState = []) {\n    const cellState = document.querySelectorAll('.field-row');\n\n    return [...cellState].map((row, y) => {\n      const cells = [...row.children];\n      const updatedRow = [];\n\n      for (let x = 0; x < cells.length; x++) {\n        const cell = cells[x];\n        const newCell = new Cell(cell, x, y);\n\n        if (initialState.length > 0) {\n          const initialRow = initialState[y];\n          const initialValue = initialRow[x];\n\n          if (initialValue !== 0) {\n            const tile = new Tile(newCell, initialValue);\n\n            newCell.tile = tile;\n          }\n        }\n\n        updatedRow.push(newCell);\n      }\n\n      return updatedRow;\n    });\n  }\n\n  get randomCell() {\n    const randomCells = [];\n\n    this.board.forEach((row, y) => {\n      for (let x = 0; x < row.length; x++) {\n        if (!row[x] || row[x] === 0) {\n          randomCells.push([x, y]);\n        }\n      }\n    });\n\n    if (randomCells.length === 0) {\n      return;\n    }\n\n    const index = Math.floor(Math.random() * randomCells.length);\n\n    return randomCells[index];\n  }\n\n  newTile() {\n    const randomCell = this.randomCell;\n\n    if (!randomCell) {\n      return;\n    }\n\n    const [x, y] = randomCell;\n    const randomValue = Math.random() <= 0.1 ? 4 : 2;\n\n    this.board[y][x] = randomValue;\n\n    let cell;\n\n    if (this.cellState[y]) {\n      cell = this.cellState[y][x];\n    }\n\n    return { cell, randomValue };\n  }\n\n  getCoords(cell) {\n    const x = +cell.dataset.x;\n    const y = +cell.dataset.y;\n\n    return { x, y };\n  }\n\n  moveCells(board) {\n    this.mergedTiles = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const boardRow = board[y];\n\n      for (let x = 1; x < boardRow.length; x++) {\n        const cell = boardRow[x];\n\n        if (cell === 0) {\n          continue;\n        }\n\n        let lastValidIndex;\n\n        for (let i = x - 1; i >= 0; i--) {\n          const moveToCell = boardRow[i];\n\n          const isCellMerged =\n            this.mergedTiles.length > 0\n              ? this.mergedTiles.find(([x1, y1]) => i === x1 && y === y1)\n              : false;\n\n          if (!this.canCellAcceptTile(moveToCell, cell, isCellMerged)) {\n            break;\n          }\n          lastValidIndex = i;\n        }\n\n        if (lastValidIndex || lastValidIndex === 0) {\n          if (boardRow[lastValidIndex] === boardRow[x]) {\n            this.mergedTiles.push([lastValidIndex, y]);\n            boardRow[lastValidIndex] = boardRow[x] * 2;\n            this.mergedTilesValues.push(boardRow[x] * 2);\n          }\n\n          if (boardRow[lastValidIndex] === 0) {\n            boardRow[lastValidIndex] = boardRow[x];\n          }\n\n          boardRow[x] = 0;\n        }\n      }\n    }\n\n    return board;\n  }\n\n  canCellAcceptTile(targetCell, tile, isCellMerged) {\n    return !targetCell || (targetCell === tile && !isCellMerged);\n  }\n\n  get cellsByColumn() {\n    const board = this.cellState;\n    const newBoard = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const column = board.map((row) => row[y]);\n\n      newBoard.push(column);\n    }\n\n    return newBoard;\n  }\n\n  get tableByColumn() {\n    const board = this.cellState;\n    const newBoard = [];\n\n    for (let y = 0; y < board.length; y++) {\n      const column = board.map((row) => row[y]);\n\n      newBoard.push(column);\n    }\n\n    return newBoard;\n  }\n\n  slideTiles(group) {\n    return Promise.all(\n      group.flatMap((cells) => {\n        const promises = [];\n\n        for (let x = 1; x < cells.length; x++) {\n          const cellTile = cells[x].tile;\n          const currentCell = cells[x];\n\n          if (!cellTile) {\n            continue;\n          }\n\n          let lastValidCell;\n\n          for (let i = x - 1; i >= 0; i--) {\n            const moveToCell = cells[i];\n\n            if (!moveToCell.canAcceptTile(cellTile)) {\n              break;\n            }\n\n            lastValidCell = moveToCell;\n          }\n\n          if (lastValidCell) {\n            if (lastValidCell.tile) {\n              promises.push(cellTile.waitForTransition());\n\n              if (!lastValidCell.mergeTile) {\n                lastValidCell.mergeTile = cellTile;\n              }\n            } else {\n              lastValidCell.tile = cellTile;\n              promises.push(cellTile.waitForTransition());\n            }\n\n            currentCell.tile = null;\n          }\n        }\n\n        return promises;\n      }),\n    );\n  }\n\n  canMove(group) {\n    return group.some((row, y) => {\n      return row.some((cell, index) => {\n        if (index === 0) {\n          return false;\n        }\n\n        if (cell === 0) {\n          return false;\n        }\n\n        return this.canCellAcceptTile(row[index - 1], cell, false);\n      });\n    });\n  }\n\n  getElementsByColumn(group) {\n    const newBoard = [];\n\n    for (let y = 0; y < group.length; y++) {\n      const column = group.map((row) => row[y]);\n\n      newBoard.push(column);\n    }\n\n    return newBoard;\n  }\n\n  getReversed(group) {\n    return group.map((column) => [...column].reverse());\n  }\n\n  canMoveLeft() {\n    return this.canMove(this.board);\n  }\n  canMoveRight() {\n    const reversed = this.getReversed(this.board);\n\n    return this.canMove(reversed);\n  }\n  canMoveUp() {\n    const stateByColumn = this.getElementsByColumn(this.board);\n\n    return this.canMove(stateByColumn);\n  }\n\n  canMoveDown() {\n    const stateByColumn = this.getElementsByColumn(this.board);\n    const reversed = this.getReversed(stateByColumn);\n\n    return this.canMove(reversed);\n  }\n\n  get noMovesPossible() {\n    return (\n      !this.canMoveDown() &&\n      !this.canMoveUp() &&\n      !this.canMoveLeft() &&\n      !this.canMoveRight()\n    );\n  }\n\n  isWinner() {\n    return this.mergedTilesValues.some((cell) => cell === 2048);\n  }\n}\n\nclass Cell {\n  #tile;\n  #mergeTile;\n\n  constructor(cellElement, x, y) {\n    this.cellElement = cellElement;\n    this.x = x;\n    this.y = y;\n  }\n\n  set tile(value) {\n    this.#tile = value;\n\n    if (!value) {\n      return;\n    }\n\n    this.tile.x = +this.x;\n    this.tile.y = +this.y;\n  }\n\n  get tile() {\n    return this.#tile;\n  }\n  get mergeTile() {\n    return this.#mergeTile;\n  }\n\n  set mergeTile(value) {\n    this.#mergeTile = value;\n\n    if (!value) {\n      return;\n    }\n\n    this.#mergeTile.x = this.x;\n    this.#mergeTile.y = this.y;\n  }\n\n  canAcceptTile(tile) {\n    return !this.tile || (this.tile.value === tile.value && !this.mergeTile);\n  }\n\n  mergeTiles() {\n    if (!this.tile || !this.#mergeTile) {\n      return;\n    }\n\n    this.tile.value = +this.tile.value + +this.#mergeTile.value;\n\n    this.#mergeTile.remove();\n    this.#mergeTile = null;\n  }\n}\n\nclass Tile {\n  #x;\n  #y;\n  #value;\n\n  constructor(parentElement, initValue) {\n    const newTile = document.createElement('div');\n    const { cellElement, x, y } = parentElement;\n\n    newTile.style.setProperty('--coord-y', y);\n    newTile.style.setProperty('--coord-x', x);\n    newTile.textContent = initValue;\n\n    newTile.className = `field-cell game-cell field-cell--${initValue}`;\n    this.tileElement = newTile;\n    this.#x = x;\n    this.#y = y;\n    this.#value = +initValue;\n    cellElement.append(newTile);\n  }\n\n  set x(coordX) {\n    this.#x = +coordX;\n    this.tileElement.style.setProperty('--coord-x', +coordX);\n  }\n\n  get x() {\n    return this.#x;\n  }\n\n  set y(coordY) {\n    this.#y = +coordY;\n    this.tileElement.style.setProperty('--coord-y', +coordY);\n  }\n\n  get y() {\n    return this.#y;\n  }\n\n  set value(value1) {\n    if (value1) {\n      this.#value = +value1;\n      this.tileElement.textContent = value1.toString();\n      this.tileElement.className = `field-cell game-cell field-cell--${value1}`;\n    }\n  }\n\n  get value() {\n    return this.#value;\n  }\n\n  remove() {\n    this.tileElement.remove();\n  }\n\n  waitForTransition() {\n    return new Promise((resolve) => {\n      this.tileElement.addEventListener('transitionend', resolve, {\n        once: true,\n      });\n    });\n  }\n}\n\nmodule.exports = Game;\n"],"names":["$a5fd07fa01589658$var$Cell","constructor","cellElement","x","y","tile","value","mergeTile","canAcceptTile","mergeTiles","remove","$a5fd07fa01589658$var$Tile","parentElement","initValue","newTile","document","createElement","style","setProperty","textContent","className","tileElement","append","coordX","coordY","value1","toString","waitForTransition","Promise","resolve","addEventListener","once","$09e991522ca7e64e$var$game","initialState","board","JSON","parse","stringify","gameIsStarted","mergedTiles","mergedTilesValues","cellState","createCellState","highScore","localStorage","getItem","updateHighScore","score","getScore","setItem","moveLeft","canMoveLeft","moveCells","cell","randomValue","slideTiles","finally","moveRight","canMoveRight","reversedState","getReversed","map","row","reverse","moveUp","canMoveUp","stateByColumn","getElementsByColumn","cellsByColumn","moveDown","canMoveDown","revertReverseState","column","reduce","sum","getState","getStatus","isWinner","noMovesPossible","start","cell2","randomValue2","restart","forEach","i","length","querySelectorAll","cells","children","updatedRow","newCell","initialValue","initialRow","push","randomCell","randomCells","index","Math","floor","random","getCoords","dataset","boardRow","lastValidIndex","moveToCell","isCellMerged","find","x1","y1","canCellAcceptTile","targetCell","newBoard","tableByColumn","group","all","flatMap","promises","lastValidCell","cellTile","currentCell","canMove","some","reversed","$09e991522ca7e64e$var$button","querySelector","$09e991522ca7e64e$var$messages","$09e991522ca7e64e$var$startMessage","$09e991522ca7e64e$var$gameScore","$09e991522ca7e64e$var$bestScore","$09e991522ca7e64e$var$highScore","parseInt","$09e991522ca7e64e$var$setupInput","$09e991522ca7e64e$var$handleInput","e","gameStatus","key","flat","message","classList","contains","$09e991522ca7e64e$var$handleScoreChange","currentScore","isStartButton","replace","add","toggle"],"version":3,"file":"index.b331b32c.js.map"}